# Persistent-Data-Structures

Курсовой проект по дисциплине "Современные методы программирования" - "Persistent data structures"

## Разработчики: 
* *Карицкая Полина, 24225.1*
* *Пучков Дмитрий, 24225.1*

---
## Оглавление
- [Persistent-Data-Structures](#persistent-data-structures)
  - [Разработчики:](#разработчики)
  - [Оглавление](#оглавление)
  - [Описание задания](#описание-задания)
  - [Базовые требования](#базовые-требования)
  - [Дополнительные требования](#дополнительные-требования)
  - [Календарный план](#календарный-план)
  - [Ожидаемое решение](#ожидаемое-решение)
  - [Теоретическая часть](#теоретическая-часть)
    - [Персистентные структуры данных](#персистентные-структуры-данных)
    - [Fat node](#fat-node)
    - [Path copying](#path-copying)
    - [Более эффективное по скорости доступа представление структур данных](#более-эффективное-по-скорости-доступа-представление-структур-данных)
  - [API](#api)
  - [Используемые источники](#используемые-источники)

---
## Описание задания

Реализовать библиотеку в Python со структурами данных в persistent-вариантах.

---
## Базовые требования
- [ ] Массив (константное время доступа, переменная длина)
- [ ] Двусвязный список
- [ ] Ассоциативный массив (на основе Hash-таблицы, либо бинарного дерева)

---
## Дополнительные требования
- [ ] Обеспечить произвольную вложенность данных (по аналогии с динамическими языками), не отказываясь при этом
  полностью от типизации посредством generic/template;
- [ ] Реализовать универсальный undo-redo механизм для перечисленных структур с поддержкой каскадности (для вложенных
  структур);
- [ ] Реализовать более эффективное по скорости доступа представление структур данных, чем fat-node.

---
## Календарный план

| **Сроки**          | **Этап работы**                                                                 | **Разделение ответственностей**                                                                                              |
|--------------------|----------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------|
| **до 23.11.2024**  | - Создание каркаса проекта <br> - Создание репозитория на GitHub                 | - Ответственный за настройку проекта и репозитория: *Полина* <br> - Ответственный за организацию структуры файлов и начальную настройку CI/CD: *совместно* |
| **до 07.12.2024**  | **Реализация базовой функциональности:** <br> - Массив (Persistent Array) <br> - Двусвязный список (Persistent Linked List) <br> - Ассоциативный массив (Persistent Map) <br> - Создание единого API | - Ответственный за реализацию Persistent Array: *_* <br> - Ответственный за реализацию Persistent Linked List: *_* <br> - Ответственный за реализацию Persistent Map: *_* <br> - Ответственный за создание API: *совместно* |
| **до 21.12.2024**  | **Реализация дополнительной функциональности:** <br> - Реализовать более эффективное по скорости доступа представление структур данных, чем fat-node <br> - Обеспечить произвольную вложенность данных (по аналогии с динамическими языками) <br> - Реализовать универсальный undo-redo механизм для перечисленных структур с поддержкой каскадности | - Ответственный за улучшение представления структур данных: *_* <br> - Ответственный за реализацию вложенности данных: *_* <br> - Ответственный за разработку механизма undo-redo: *_* |

---
## Ожидаемое решение

Ожидаемое решение состоит в разработке библиотеки, которая будет поддерживать следующие структуры данных:

1. **Persistent Array** - массив с возможностью добавления элементов без изменения предыдущих состояний. Операции должны поддерживать константное время доступа.
   
2. **Persistent Linked List** - двусвязный список с поддержкой добавления и удаления элементов, при этом сохраняется возможность обратиться к предыдущим состояниям списка.

3. **Persistent Map** - ассоциативный массив, реализованный на основе хеш-таблицы или бинарного дерева поиска. Это будет позволять эффективно работать с данными, при этом поддерживать возможность обращения к предыдущим версиям данных.

4. **Оптимизация доступа к данным** - предложим более эффективное представление данных для ускорения операций доступа по сравнению с fat-node.

5. **Типизация данных** - обеспечим произвольную вложенность данных, при этом не отказываясь от строгой типизации через generic или template.

6. **Undo/Redo Механизм** - реализуем механизм для всех структур данных, который позволит отменять и повторять изменения, причем для вложенных структур будет поддерживаться каскадность.


Каждая из структур данных будет поддерживать все основные операции: вставку, удаление, обновление, поиск, а также предоставлять возможность работы с предыдущими версиями данных через устойчивость (persistent) данных. Вся библиотека будет иметь единый API для работы с данными и их модификацией. Также будет обеспечена возможность взаимодействия с данными в виде вложенных структур.

---
## Теоретическая часть

### Персистентные структуры данных

**Персистентные структуры данных** сохраняют предыдущие версии при изменении. Структура называется *fully persistent*, если все её версии доступны для изменений. В *partially persistent* структурах можно изменять только последнюю версию, но доступ к предыдущим возможен. Эти структуры часто реализуются с использованием алгоритмов, таких как path copying, node copying и fat node, а также с применением бинарных деревьев поиска и красно-черных деревьев.

Персистентные структуры используются в вычислительной геометрии, объектно-ориентированном программировании, текстовых редакторах, симуляциях и системах контроля версий, таких как Git.

### Fat node

*Fat node* используется для создания персистентных структур данных, где изменения сохраняются только в измененных узлах дерева, а сами узлы могут расширяться, чтобы хранить все версии. Основной принцип заключается в том, чтобы хранить обновления и версии данных в списках, что позволяет эффективно отслеживать изменения в структуре.

**Преимущества:**

* Экономия памяти, так как изменяются только те части данных, которые действительно изменились;
* Быстрая работа с историей изменений.

**Недостатки:**

* Может быть менее эффективен для структур с частыми изменениями, так как увеличение размера узлов приводит к дополнительным затратам на память.

Можно посмотреть [визуализацию метода *fat node*](https://kumom.io/persistent-bst).

### Path copying

Метод *path copying* используется для создания персистентных структур данных, где при изменении узла создается его копия, и нужно пройти по всем узлам от измененного до корня, чтобы обновить ссылки на новый узел. Этот метод упрощает доступ к данным, так как для поиска нужной версии достаточно пройти путь от корня.

**Преимущества:**

* Быстрый доступ к данным;
* Простота в реализации.

**Недостатки:**

* Большие затраты на память, поскольку изменения могут потребовать копирования всей структуры;
* Могут возникать дополнительные накладные расходы при частых модификациях.

Метод *path copying* также используется для создания полностью персистентных структур данных.

На иллюстрации продеминстрирован пример использования *path copying* на бинарном дереве поиска. При внесении изменения создается новый корень, при этом старый корень сохраняется для дальнейшего использования (он показан темно-серым цветом). Заметим также, что старое и новое деревья частично делят общую структуру.

![Пример использования path copying](path_copying.png)

### Более эффективное по скорости доступа представление структур данных

Поскольку одно из требований — использование более эффективного подхода по сравнению с методом *fat-node*, в проекте будет применяться метод *path copying*, совмещённая с использованием структуры B-деревьев для улучшения производительности.

---
## API

Для работы с персистентными структурами данных используйте следующий API:

Создание объекта:
```python
obj = [PersistentDataStructure]([args])
```
Обращение к элементу текщей версии:
```python
obj[index]
```
Обращение к элементу произвольной версии:
```python
obj.get(index, version)
```

Добавление элемента в новую версию:
```python
obj.append(element)
```
Удаление элемента в новой версии и возвращение элемента:
```python
obj.pop(index)
```

Обновление элемента в новой версии:
```python
obj[index] = element
```

Вставка элемента в новую версию:
```python
obj.insert(index, element)
```

Удаление элемента в новой версии:
```python
obj.remove(index)
```




---
## Используемые источники

1. Milan Straka, "Functional Data Structures and Algorithms", Computer Science Institute of Charles University, Prague 2013

2. Крис Окасаки, "Чисто функциональные структуры данных", 2018

3. Статья на Geeks for geeks ["Persistent data structures"](https://www.geeksforgeeks.org/persistent-data-structures/)

4. Несколько статей по персистентным векторам: 

    * [Understanding Clojure's Persistent Vectors, pt. 1](https://hypirion.com/musings/understanding-persistent-vector-pt-1)
    * [Understanding Clojure's Persistent Vectors, pt. 2](https://hypirion.com/musings/understanding-persistent-vector-pt-2)
    * [Understanding Clojure's Persistent Vectors, pt. 3](https://hypirion.com/musings/understanding-persistent-vector-pt-3)

5. Driscoll J. R. et al. Making data structures persistent //Proceedings of the eighteenth annual ACM symposium on Theory of computing. – 1986. – С. 109-121.

6. Серия видео-лекций по персистентным структурам данных:

    * ["Visualizing Persistent Data Structures" by Dann Toliver](https://www.youtube.com/watch?v=2XH_q494U3U)
    * [Persistent Data Structures, MIT](https://www.youtube.com/watch?v=T0yzrZL1py0)