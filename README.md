# Persistent-Data-Structures

Курсовой проект по дисциплине "Современные методы программирования" - "Persistent data structures"

## Разработчики: 
* *Карицкая Полина, 24225.1*
* *Пучков Дмитрий, 24225.1*

---
## Оглавление
- [Persistent-Data-Structures](#persistent-data-structures)
  - [Разработчики:](#разработчики)
  - [Оглавление](#оглавление)
  - [Описание задания](#описание-задания)
  - [Базовые требования](#базовые-требования)
  - [Дополнительные требования](#дополнительные-требования)
  - [Календарный план](#календарный-план)
  - [Ожидаемое решение](#ожидаемое-решение)
  - [Теоретическая часть](#теоретическая-часть)
    - [Персистентные структуры данных](#персистентные-структуры-данных)
    - [Fat node](#fat-node)
    - [Path copying](#path-copying)
    - [Более эффективное по скорости доступа представление структур данных](#более-эффективное-по-скорости-доступа-представление-структур-данных)
  - [API](#api)
  - [Примеры использования](#примеры-использования)
    - [Массив (Persistent Array)](#массив-persistent-array)
    - [Список (Persistent Linked List)](#список-persistent-linked-list)
    - [Aссоциативный массив (Persistent Map)](#aссоциативный-массив-persistent-map)
    - [Двусвязный список (Persistent Linked List)](#двусвязный-список-persistent-linked-list)
    - [Ассоциативный массив (Persistent Map)](#ассоциативный-массив-persistent-map)
  - [Используемые источники](#используемые-источники)

---
## Описание задания

Реализовать библиотеку в Python со структурами данных в persistent-вариантах.

---
## Базовые требования
- [x] Массив (константное время доступа, переменная длина)
- [x] Двусвязный список
- [ ] Ассоциативный массив (на основе Hash-таблицы, либо бинарного дерева)

---
## Дополнительные требования
- [x] Реализовать более эффективное по скорости доступа представление структур данных, чем fat-node;
- [ ] Обеспечить произвольную вложенность данных (по аналогии с динамическими языками), не отказываясь при этом
  полностью от типизации посредством generic/template;
- [ ] Реализовать универсальный undo-redo механизм для перечисленных структур с поддержкой каскадности (для вложенных структур).


---
## Календарный план

| **Сроки**          | **Этап работы**                                                                 | **Разделение ответственностей**                                                                                              |
|--------------------|----------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------|
| **до 23.11.2024**  | - Создание каркаса проекта <br> - Создание репозитория на GitHub                 | - Ответственный за настройку проекта и репозитория: *Полина* <br> - Ответственный за организацию структуры файлов и начальную настройку CI/CD: *совместно* |
| **до 07.12.2024**  | **Реализация базовой функциональности:** <br> - Массив (Persistent Array) <br> - Двусвязный список (Persistent Linked List) <br> - Ассоциативный массив (Persistent Map) <br> - Создание единого API | - Ответственный за реализацию Persistent Array: *_* <br> - Ответственный за реализацию Persistent Linked List: *Полина* <br> - Ответственный за реализацию Persistent Map: *Дмитрий* <br> - Ответственный за создание API: *совместно* |
| **до 21.12.2024**  | **Реализация дополнительной функциональности:** <br> - Реализовать более эффективное по скорости доступа представление структур данных, чем fat-node <br> - Обеспечить произвольную вложенность данных (по аналогии с динамическими языками) <br> - Реализовать универсальный undo-redo механизм для перечисленных структур с поддержкой каскадности | - Ответственный за улучшение представления структур данных: *совместно* <br> - Ответственный за реализацию вложенности данных: *совместно* <br> - Ответственный за разработку механизма undo-redo: *совместно* |

---
## Ожидаемое решение

Ожидаемое решение состоит в разработке библиотеки, которая будет поддерживать следующие структуры данных:

1. **Persistent Array** - массив с возможностью добавления элементов без изменения предыдущих состояний. Операции должны поддерживать константное время доступа.
   
2. **Persistent Linked List** - двусвязный список с поддержкой добавления и удаления элементов, при этом сохраняется возможность обратиться к предыдущим состояниям списка.

3. **Persistent Map** - ассоциативный массив, реализованный на основе хеш-таблицы или бинарного дерева поиска. Это будет позволять эффективно работать с данными, при этом поддерживать возможность обращения к предыдущим версиям данных.

4. **Оптимизация доступа к данным** - предложим более эффективное представление данных для ускорения операций доступа по сравнению с fat-node.

5. **Типизация данных** - обеспечим произвольную вложенность данных, при этом не отказываясь от строгой типизации через generic или template.

6. **Undo/Redo Механизм** - реализуем механизм для всех структур данных, который позволит отменять и повторять изменения, причем для вложенных структур будет поддерживаться каскадность.


Каждая из структур данных будет поддерживать все основные операции: вставку, удаление, обновление, поиск, а также предоставлять возможность работы с предыдущими версиями данных через устойчивость (persistent) данных. Вся библиотека будет иметь единый API для работы с данными и их модификацией. Также будет обеспечена возможность взаимодействия с данными в виде вложенных структур.

---
## Теоретическая часть

### Персистентные структуры данных

**Персистентные структуры данных** сохраняют предыдущие версии при изменении. Структура называется *fully persistent*, если все её версии доступны для изменений. В *partially persistent* структурах можно изменять только последнюю версию, но доступ к предыдущим возможен. Эти структуры часто реализуются с использованием алгоритмов, таких как path copying, node copying и fat node, а также с применением бинарных деревьев поиска и красно-черных деревьев.

Персистентные структуры используются в вычислительной геометрии, объектно-ориентированном программировании, текстовых редакторах, симуляциях и системах контроля версий, таких как Git.

### Fat node

*Fat node* используется для создания персистентных структур данных, где изменения сохраняются только в измененных узлах дерева, а сами узлы могут расширяться, чтобы хранить все версии. Основной принцип заключается в том, чтобы хранить обновления и версии данных в списках, что позволяет эффективно отслеживать изменения в структуре.

**Преимущества:**

* Экономия памяти, так как изменяются только те части данных, которые действительно изменились;
* Быстрая работа с историей изменений.

**Недостатки:**

* Может быть менее эффективен для структур с частыми изменениями, так как увеличение размера узлов приводит к дополнительным затратам на память.

Можно посмотреть [визуализацию метода *fat node*](https://kumom.io/persistent-bst).

### Path copying

Метод *path copying* используется для создания персистентных структур данных, где при изменении узла создается его копия, и нужно пройти по всем узлам от измененного до корня, чтобы обновить ссылки на новый узел. Этот метод упрощает доступ к данным, так как для поиска нужной версии достаточно пройти путь от корня.

**Преимущества:**

* Быстрый доступ к данным;
* Простота в реализации.

**Недостатки:**

* Большие затраты на память, поскольку изменения могут потребовать копирования всей структуры;
* Могут возникать дополнительные накладные расходы при частых модификациях.

Метод *path copying* также используется для создания полностью персистентных структур данных.

На иллюстрации продеминстрирован пример использования *path copying* на бинарном дереве поиска. При внесении изменения создается новый корень, при этом старый корень сохраняется для дальнейшего использования (он показан темно-серым цветом). Заметим также, что старое и новое деревья частично делят общую структуру.

![Пример использования path copying](path_copying.png)

### Более эффективное по скорости доступа представление структур данных

Поскольку одно из требований — использование более эффективного подхода по сравнению с методом *fat-node*, в проекте будет применяться метод *path copying*, совмещённая с использованием структуры B-деревьев для улучшения производительности.

---
## API

Для работы с персистентными структурами данных используйте следующий API:

Создание объекта:
```python
obj = [PersistentDataStructure]([args])
```

Обращение к элементу текщей версии:
```python
obj[index]
```

Обращение к элементу произвольной версии:
```python
obj.get(version, index)
```

Добавление элемента в новую версию:
```python
obj.add(element)
```

Удаление элемента в новой версии и возвращение элемента:
```python
obj.pop(index)
```

Обновление элемента в новой версии:
```python
obj[index] = element
```

Вставка элемента в новую версию:
```python
obj.insert(index, element)
```

Удаление элемента в новой версии:
```python
obj.remove(index)
```

Возвращение количества элементов в текущей версии:
```python
obj.size()
```

Проверка на пустоту:
```python
obj.check_is_empty()
```

Проверка на полноту:
```python
obj.check_is_full()
```

Возвращение состояние объекта для указанной версии:
```python
obj.get_version(version)
```

Обновление текущей версии объекта до указанной:
```python
obj.update_version(version)
```

---
## Примеры использования

### Массив (Persistent Array)

Представленный код реализует персистентный массив с использованием метода path copying, что позволяет создать новый массив (или версию массива) с изменениями, не изменяя предыдущие версии.

1. **Константное время доступа к элементам (O(1)):** метод `__getitem__` обеспечивает доступ к элементу массива за константное время. Это достигается благодаря тому, что все версии массива хранятся в виде списков, и доступ к элементам осуществляется напрямую через индекс в последней версии массива.

2. **Переменная длина (с помощью path copying):** массив имеет переменную длину (сначала 0), для каждой версии хранится копия предыдущего массива, при этом изменения происходят только в новой версии, что реализовано через path copying.

3. **Path copying:** в процессе изменения массива не изменяется старый массив, а создается новый, что позволяет сохранять неизменность всех предыдущих версий.

**Пример использования класса PersistentArray:**

Создание персистентного массива с максимальным размером 5 и значением по умолчанию 0
```python
arr = PersistentArray(max_size=5, default_value=0)
```

Добавление элементов в массив
```python
arr.add(10) 
arr.add(20)  
arr.add(30)
print("Элемент на индексе 1 в текущей версии:", arr[1])
```

```console
Элемент на индексе 1 в текущей версии: 20
```

Удаление элемента по индексу
```python
removed_value = arr.pop(1)
print("Удаленный элемент:", removed_value)
```

```console
Удаленный элемент: 20
```

Получение версий массива
```python
print("Состояние массива в версии 0:", arr.get_version(0)) 
print("Состояние массива в версии 1:", arr.get_version(1))
```

```console
Состояние массива в версии 0: [0, 0, 0]
Состояние массива в версии 1: [10, 0, 0]
```

Обновление текущей версии до версии 2
```python
arr.update_version(2)
print("Массив после обновления до версии 2:", arr.get_version(2))
```

```console
Массив после обновления до версии 2: [10, 20, 0, 0, 0]
```

### Список (Persistent Linked List)

### Aссоциативный массив (Persistent Map)
Примеры использования:
```
    >>> map = PersistentMap({'foo': 'bar'}) # Создаем пустой ассоциативный массив
    >>> map['key'] = 'value' # Добавляем элемент
    >>> map['key'] = 'value2' # Изменяем элемент в следующей версии
    >>> map['key'] # Получаем элемент последней версии
    'value2'
    >>> map.get(1, 'key')
    {'key': 'value'}
    >>> map.remove('key') # Удаляем элемент в новой версии
    >>> map.clear() # Очищаем ассоциативный массив в новой версии
    >>> map.get(0, 'key') # Пытаемся получить элемент отсутствующий в переданной версии
    Traceback (most recent call last):
        ...
    KeyError: Key "key" does not exist
```

**Сравнение методов Path Copy и Fat Node для реализации персистентных массивов**

| **Характеристика**                     | **Метод Path Copy**                                                                                 | **Метод Fat Node**                                                                                  |
|----------------------------------------|-----------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------|
| **Описание**                           | В каждой версии массива создается копия всех предыдущих элементов с изменениями только в текущей версии. | Используется структура узлов, где каждый узел содержит данные и ссылку на предыдущую версию.      |
| **Механизм создания версии**          | Каждая новая версия — это копия всей предыдущей версии с изменениями (копирование всей структуры).   | Каждая новая версия — это новый узел, который содержит данные и ссылку на предыдущий узел.         |
| **Память**                             | Каждая версия массива занимает память, так как все данные копируются, что может быть неэффективным при большом размере массива. | Память используется более эффективно, так как каждый узел ссылается на предыдущую версию, уменьшая объем хранения. |
| **Добавление элемента**                | Для добавления элемента создается новая версия массива, которая копирует все предыдущие элементы и добавляет новый. | Для добавления элемента создается новый узел с данными, ссылкой на предыдущий узел, и новый элемент добавляется в данные этого узла. |
| **Удаление элемента**                  | Удаление элемента приводит к созданию новой версии массива, где удален элемент, а остальные данные остаются неизменными. | Удаление элемента создает новый узел с обновленными данными и ссылкой на предыдущий узел, который содержит старые данные. |
| **Обновление элемента**                | Для обновления элемента создается новая версия с измененным элементом, остальные данные сохраняются. | Обновление элемента происходит в новом узле с сохранением ссылки на предыдущую версию данных. |
| **Извлечение элемента по индексу**     | Извлечение элемента происходит из текущей версии массива, которая содержит все элементы до текущей версии. | Извлечение элемента происходит из текущего узла, где данные хранятся в списке, связанном с предыдущими узлами. |
| **Поиск версии**                       | Для поиска данных из старой версии требуется пройти через все предыдущие версии.                   | Для поиска версии достаточно просто получить нужный узел по его индексу. |
| **Управление размером массива**        | Размер массива ограничен, каждый новый элемент добавляется в конец массива.                        | Размер массива ограничен, но изменения происходят с использованием структуры узлов, что позволяет эффективно работать с изменениями. |
| **Производительность**                 | При большом количестве изменений производительность может пострадать из-за копирования всей версии. | Лучше с точки зрения производительности, так как создается только один новый узел, а не копируется вся версия. |
| **Использование в многопоточности**    | Может требовать блокировки или дополнительных механизмов синхронизации, так как массив в целом копируется. | Каждый узел связан с предыдущим, что позволяет более гибко управлять изменениями в многопоточном режиме. |


### Двусвязный список (Persistent Linked List)

Представленный код реализует персистентный двусвязный список с возможностью хранения версий. Список позволяет сохранять состояния на каждом изменении и возвращать любые из этих состояний по запросу. Каждое изменение сохраняется в новую версию списка, что позволяет «откатить» список к любой из предыдущих версий.

**Ключевые особенности:**

1. `Персистентность`: После каждого изменения сохраняется версия списка;

2. `Двусвязный список`: Каждый элемент имеет ссылки на предыдущий и следующий узлы, что позволяет эффективно вставлять и удалять элементы в обоих направлениях;

3. `История изменений`: Каждый раз, когда состояние списка изменяется, оно сохраняется в истории, позволяя вернуться к любому состоянию списка.

**Реализация path copying:**

1. Метод `_copy_node` создает копию узла списка, что позволяет избежать изменения оригинальных узлов, создавая новые копии для каждой версии;

2. Метод `_copy_list` создает новый список на основе текущего состояния списка, что также подтверждает использование копирования для создания новых версий;

3. Атрибут `history` хранит историю состояний списка. При добавлении, удалении или изменении элементов сохраняется новая версия списка с копией текущего состояния.

**Пример использования класса PersistentLinkedList:**

Создание персистентного двусвязного списка с максимальным размером 5
```python
plist = PersistentLinkedList(max_size=5)
```

Добавление элементов
```python
plist.add(10)
plist.add_first(5)
print("Текущий список:", plist.get())
```

Просмотр текущей версии списка
```console
Текущий список: [5, 10]
```

Дополнительное добавление элементов
```python
plist.add(20)
plist.add(30)
print("Текущий список после добавления элементов:", plist.get())
```

```console
Текущий список после добавления элементов: [5, 10, 20, 30]
```

Сохранение версии списка
```python
plist.save_to_history()
```

Удаление элемента по индексу
```python
removed_value = plist.remove(1)
print("Удаленный элемент:", removed_value)
print("Список после удаления:", plist.get())
print("Состояние списка на версии 0:", plist.get_version(0)) 
```

```console
Удаленный элемент: 10
Список после удаления: [5, 20, 30]
Состояние списка на версии 0: []
```

Обновление текущей версии списка на третью
```python
plist.update_version(3)
print("Состояние списка после обновления версии на 3:", plist.get())
```

```console
Состояние списка после обновления версии на 3: [5, 10, 20]
```

**Сравнение path copying метода с fat node:**


| Характеристика                  | **Path Copy**                               | **Fat Node**                                |
|----------------------------------|---------------------------------------------|---------------------------------------------|
| **Структура данных**             | Каждый узел списка хранит только данные и ссылки на соседние узлы. | Каждый узел списка хранит данные, ссылки на соседние узлы и версию узла. |
| **Механизм сохранения версий**   | Вся версия списка сохраняется путем копирования всех узлов и их ссылок. | Каждое изменение сохраняется в виде нового узла, который хранит состояние для каждого элемента. |
| **Реализация изменений**         | Изменения сохраняются, создавая копии всех узлов в новой версии списка. | Каждое изменение представляет собой добавление нового узла с информацией о версии. |
| **Использование памяти**         | Требует копирования всех узлов, что может быть неэффективно при большом объеме данных. | Использует больше памяти за счет хранения данных и версии для каждого узла. |
| **Поддержка операций**           | Поддерживает добавление, удаление, вставку и доступ к элементам для каждой версии. | Поддерживает те же операции, но каждая операция сохраняет состояние узла в новой версии. |
| **Производительность**           | Может быть менее эффективным при частых изменениях, поскольку копируются все узлы. | Может быть более эффективным для частых изменений, так как изменения происходят только в новых узлах. |
| **История версий**               | Сохраняет полную историю списка в виде отдельных копий. | Сохраняет версии каждого узла, что позволяет эффективно управлять историей изменений. |
| **Простота реализации**          | Проще реализовать, так как требуется лишь копирование узлов. | Реализация сложнее, так как нужно поддерживать версии для каждого узла. |
| **Типы операций**                | Позволяет изменять весь список (копирование всех узлов) или доступ к элементам на различных версиях. | Операции изменяют только отдельные узлы, что дает большую гибкость в управлении изменениями. |
| **Обработка больших данных**     | Менее эффективен для больших списков, так как требует копирования всего списка. | Более эффективен для больших списков, так как хранит изменения только для затронутых узлов. |
| **Поддержка сложных операций**   | Легче для реализации простых операций (добавление, удаление, вставка). | Сложнее для реализации сложных операций, так как для каждого узла нужно учитывать версию. |
| **Гибкость**                     | Меньше гибкости, поскольку операции требую пересоздания всего списка. | Более гибкий подход, так как изменения можно локализовать в конкретных узлах. |


### Ассоциативный массив (Persistent Map)

---
## Используемые источники

1. Milan Straka, "Functional Data Structures and Algorithms", Computer Science Institute of Charles University, Prague 2013

2. Крис Окасаки, "Чисто функциональные структуры данных", 2018

3. Статья на Geeks for geeks ["Persistent data structures"](https://www.geeksforgeeks.org/persistent-data-structures/)

4. Несколько статей по персистентным векторам: 

    * [Understanding Clojure's Persistent Vectors, pt. 1](https://hypirion.com/musings/understanding-persistent-vector-pt-1)
    * [Understanding Clojure's Persistent Vectors, pt. 2](https://hypirion.com/musings/understanding-persistent-vector-pt-2)
    * [Understanding Clojure's Persistent Vectors, pt. 3](https://hypirion.com/musings/understanding-persistent-vector-pt-3)

5. Driscoll J. R. et al. Making data structures persistent //Proceedings of the eighteenth annual ACM symposium on Theory of computing. – 1986. – С. 109-121.

6. Серия видео-лекций по персистентным структурам данных:

    * ["Visualizing Persistent Data Structures" by Dann Toliver](https://www.youtube.com/watch?v=2XH_q494U3U)
    * [Persistent Data Structures, MIT](https://www.youtube.com/watch?v=T0yzrZL1py0)